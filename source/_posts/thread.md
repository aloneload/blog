---
title: java多线程 
categories: 
- 编程语言
tags: 
- java 
- 多线程 
---

## 多任务
多任务：操作系统可以同时运行多个任务。

进程：指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。

线程：线程是进程中的一个实体，作为系统调度和分派的基本单位。

- 解决方案：

1.启动多个进程

2.启动多个线程

3.多进程+多线程

如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。

- 计算密集型 vs. IO密集型
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少。


## 并行和并发

并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核 CPU上。如果一个程序要运行两个任务，并且只有一个 CPU 给它们分配了不同的时间片，那么这就是并发，而不是并行。



- 多线程优点
1.资源利用更好

2.程序响应更快

- 多线程代价
1.增加资源消耗，上下文切换开销

2.设计更复杂，对于共享资源的控制

- 竞态条件与临界区
竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。

临界区：导致竞态条件发生的代码区称作临界区。

如何避免：在临界区中使用适当的同步就可以避免竞态条件。

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。


## java多线程
一个线程的生命周期



- 创建一个线程
Java 提供了三种创建线程的方法：

1. 通过实现 Runnable 接口；
1. 通过继承 Thread 类本身；
1. 通过 Callable 和 Future 创建线程。
- 创建线程的三种方式的对比
1. 采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。
* Thread 方法
下表列出了Thread类的一些重要方法：

```
序号	方法描述
1	public void start()
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
2	public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。
3	public final void setName(String name)
改变线程名称，使之与参数 name 相同。
4	public final void setPriority(int priority)
 更改线程的优先级。
5	public final void setDaemon(boolean on)
将该线程标记为守护线程或用户线程。
6	public final void join(long millisec)
等待该线程终止的时间最长为 millis 毫秒。
7	public void interrupt()
中断线程。
8	public final boolean isAlive()
测试线程是否处于活动状态。
```


 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。


```
序号	方法描述
1	public static void yield()
暂停当前正在执行的线程对象，并执行其他线程。
2	public static void sleep(long millisec)
在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
3	public static boolean holdsLock(Object x)
当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
4	public static Thread currentThread()
返回对当前正在执行的线程对象的引用。
5	public static void dumpStack()
将当前线程的堆栈跟踪打印至标准错误流。
```

